프로그래머스 징검다리문제(lv.4)
https://school.programmers.co.kr/learn/courses/30/lessons/43236?language=python3

출발지점부터 도착지점까지의 거리 distance, 바위들이 있는 위치를 담은 배열 rocks, 제거할 바위의 수 n이 매개변수로 주어질 때, 
바위를 n개 제거한 뒤 각 지점 사이의 거리의 최솟값 중에 가장 큰 값을 return 하도록 solution 함수를 작성해주세요.

첫 솔루션
처음 이 문제를 접하였을 당시 해당 문제를 부분문제에 대한 해결방법을 조합하여 문제의 최적 해결 방법을 구성하는 최적 부분 구조 문제로 분석하였다. 
무작위의 n개의 돌 혹은 아무리 많은 돌들을 제거하더라도 최소 간격을 유지하는 돌을 제거하지 않으면 지점사이의 거리의 최솟값은 변하지 않기에 처음 돌을 제거할때 최소 간격을 유지하는 돌을 공략해나가면 각 지점 사이의 거리의 최소값 중 가장 큰 값을 얻을 수 있으리라....

0과 distance 사이 돌 들의 간격을 계산하여 배열을 생성
intervals=[rocks[i]-rocks[i-1] if i!=0 else rocks[i] for i in range(len(rocks))]

힙 자료구조 사용
많은 간격들 중 최소값을 찾아야하므로 힙생성 후 [간격, 인덱스]값의 노드들을 push (인덱스를 넣은 이유: 간격을 유지하는 돌은 왼쪽/오른쪽 총 2가지 이다. 어떤 쪽을 제거할지 결정하기 위해 왼쪽 돌을 제거함으로써 변하는 간격(현재 간격, 왼쪽돌의 왼쪽 간격)과 오른쪽 돌을 제거함으로써 변하는 간격(현재 간격, 오른쪽돌의 오른쪽 간격)을 비교해서 최소 간격을 많이 제거하는 쪽으로 선택하기 위해 인덱스 정보를 생성.)
heap=[]
for idx, interval in enumerate(intervals):
  heapq.heappush(heap, [interval, idx])
  
힙에서 가장 작은 간격을 pop하여 인접한 간격과 merge하는 순간, 문제가 발생한다. 인접한 간격의 노드 뿐만 아니라 현재 간격 이후의 노드 모두 인덱스 값을 업데이트해야 되는데 한가지 값만 추출해내는 힙 자료구조 특성상 해당 조건의 노드들을 모두 업데이트하는 것은 사실상 불가능하다.


맵(딕셔너리)
간격을 키로 설정하고 인덱스를 값으로 하는 맵 생성
for idx, val in enumerate(intervals):
  entry[val].append(i)
제일 작은 간격의 인덱스들부터 차근차근 merge(merge해나가는 방향은 현재 간격과 인접한 왼쪽/오른쪽 간격의 크기를 비교해서 크기가 작은 간격과 병합하는 것이 간격의 최소값을 최대로 만들어줄 확률이 높다고 생각) 

위 두가지 방법 모두 제일 작은 간격이 여러 개일 때의 예외처리가 관건이였다. 최소 간격이 여러 개일 경우 최소간격들의 인접간격들을 비교하여 그나마 제일 작은 인접간격을 가진 최소간격을 선택하면 풀 수 있지 않을까 했지만 fail...

잘못된 전제
곰곰히 생각해보니 문제를 풀기전에 내린 전제(최적 부분 구조 문제)부터 잘못되었다는 것을 확인
0(시작) 1/4 1/3 1/2 2/3 3/4 1(목적지)
2개의 지점을 제거했을 때의 최소 간격의 최대 값: 1/4 제거 지점[1/3, 2/3]
3개의 지점을 제거했을 때의 최소 간격의 최대 값: 1/3 제거 지점[1/4, 2/4, 3/4]
부분 문제(n-1개)에 대한 해결 방식이 꼭 전체 문제(n개) 해결 방식을 구성하는 것은 아님. 최적 부분 구조 X


이 문제가 까다로웠던 이유는 아마 "바위를 n개 제거한 뒤"라는 구절 때문이 아니였을까 생각한다. 이 구절은 마치 무조건 n개를 뽑아놓고 최소간격의 최대값을 찾아야할 것 같은 느낌을 불러일으킨다. 하지만 제거할 돌의 개수 증가가 꼭 최소 간격의 증가로 이어지지 않는다. (최소값이 여러 개일 경우)
반대로 최소 간격의 증가/감소는 제거할 돌의 개수 변동을 동반한다. 때문에 돌의 간격을 기준으로 제거해야 될 돌의 개수를 결정해야한다. 즉, 제거할 돌의 개수가 n이 되도록 최소 간격을 수정나가야 한다.
방법은 이렇다. 최소 간격의 목표값을 설정하고 해당 목표값이 최소값이 될 수 있도록 앞에서부터 차례대로 돌을 제거해나간다. 제거한 후 제거한 돌의 개수가 n을 넘어서거나(목표값을 정답보다 크게 설정한 경우) n과 같거나(목표값이 정답보다 작을 가능성 있음) 작은 경우(목표값을 정답보다 작게 설정한 경우) 이렇게 3가지 경우가 있다. 
이렇게 제거한 돌의 개수에 따라 이분탐색을 수행하면서 목표값을 수정하면 최종적으로 우리가 원하는 정답에 도달하게 된다.

풀이코드
def solution(distance, rocks, n):
    answer = 0
    rocks.sort()
    rocks.append(distance)
    low = 0
    #최소간격의 상한선(모든 간격이 고르게 분포되어 있을때)
    high = distance//(len(rocks)-n)
    while (low<= high):
        pivot = 0
        cnt = 0
        mid = (low+high)//2
        for i in range(len(rocks)):
            #제거한 돌의 개수가 n보다 커진 이상, 이후 돌을 제거하는 작업은 의미없다. 목표값이 최종값보다 크다는 것을 알았으니 상한선을 낮추고 루프를 멈춘다.
            if cnt>n:
                high=mid-1
                break
            if (rocks[i]-pivot<mid):
                cnt+=1
            else:
                pivot = rocks[i]
        if cnt<=n:
            low=mid+1
            answer=mid
    return answer
